'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sinon = require('sinon');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint-disable no-console */

/**
 * One alternative to this module is to use something like:
 *
 * let warning;
 *
 * beforeEach(() => {
 *   warning = mock(console).expects('error');
 * });
 *
 * afterEach(() => {
 *   warning.restore();
 * });
 */
var ConsoleErrorMock = function ConsoleErrorMock() {
  var _this = this;

  _classCallCheck(this, ConsoleErrorMock);

  this.spy = function () {
    _this.consoleErrorContainer = console.error;
    console.error = (0, _sinon.spy)();
  };

  this.reset = function () {
    console.error = _this.consoleErrorContainer;
    delete _this.consoleErrorContainer;
  };

  this.callCount = function () {
    if (_this.consoleErrorContainer) {
      return console.error.callCount;
    }

    throw new Error('Requested call count before spy() was called');
  };

  this.args = function () {
    if (_this.consoleErrorContainer) {
      return console.error.args;
    }

    throw new Error('Requested call count before spy() was called');
  };
};

exports.default = new ConsoleErrorMock();

//# sourceMappingURL=consoleErrorMock.js.map